---
title: HTTP学习
description: HTTP学习笔记
date: 2022-07-28
slug: 
image: 
categories:
    - 其他
    - 软件技能
tags:
    - 其他
    - 软件技能
    - HTTP
updated: 2022-07-28
comments: false
---
## HTTP协议
<a name="rozy4"></a>
### HTTP协议用于客户端和服务器端之间的通信

   - 请求访问文本或图像等资源的一端称为客户端,而提供资源响应的
<a name="icoV9"></a>
### 通过请求和响应的交换达成通信

   - 请求必定由客户端发出,而服务器端回复响应
   - 请求例子：<br />`GET /index.html HTTP/1.1`<br />`Host:hackr.jp`
      - 起始行开头的GET表示请求访问服务器的类型，称为方法(method)。随后的字符串/ index.html指明了请求访问的资源对象也叫做请求URI(request-uri)。最后的HTTP/1.1，即HTTP的版本号，用来提示客户端使用的HTTP协议功能。
   - 相应例子<br />HTTP/1.1  200 OK<br />Date: Tue, 10 Jul 2012 06: 50: 15 GMT<br />Content-length: 362<br />Content-type: text/html<br /><html>
      - 在起始行开头的HTP1.1表示服务器对应的HTTP版本。<br />紧挨着的200  OK表示请求的处理结果的状态码( status code)和原因短语(reason-phrase)。下一行显示了创建响应的日期时间,是首部字段(header field)内的一个属性。<br />接着以一空行分隔,之后的内容称为资源实体的主体( entity
<a name="SZzR4"></a>
### HTTP是不保存状态的协议
HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别,协议对于发送过的请求或响应都不做持久化处理。<br />为了实现期望的保持状态功能,于是引入了 Cookie技术。有了 Cookie再用HTP协议通信,就可以管理状态了。
<a name="otNPP"></a>
### 请求URI定位资源
当客户端请求访问资源而发送请求时,URI需要将作为请求报文中的请求URI包含在内。<br />如果不是访问特定资源而是对服务器本身发起请求,可以用一个*来代替请求URI。

   - OPTIONS * HTTP/1.1
      - 这个例子是查询HTTP服务器端支持的HTTP方法种类。
<a name="2Crtp"></a>
### 告知服务器意图的HTTP方法
<a name="ofFDw"></a>
#### GET : 获取资源
GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说,如果请求的资源是文本,那就保持原样返回;如果是像CGl( Common Gateway Interface,通用网关接)那样的程序,则返回经过执行后的输出结果

   - 例子：请求网页资源
<a name="y5Cv6"></a>
#### POST ： 传输实体主体

   - 发送“消息”

虽然用GET方法也可以传输实体的主体,但一般不用GET方法进行传输,而是用POST方法。虽说POST的功能与GET很相似,但POST的主要目的并不是获取响应的主体内容。

   - 例子：发送数据 返回服务器端接收数据的处理结果
<a name="kfWNl"></a>
#### PUT ：传输文件

   - 发送文件

         PUT方法用来传输文件。就像FTP协议的文件上传一样,要求在请求报文的主体中包含文件内容,然后保存到请求URI指定的位置。

   - 鉴于HTP/1.1的PUT方法自身不带验证机制,任何人都可以上传文件,存在安全性问题,因此一般的web网站不使用该方法。
<a name="U7yfo"></a>
#### HEAD ： 获得报文首部

   - 获取相关的信息

         HEAD方法和GET方法一样,只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。

   - 和GET一样，但不返回报文主体
<a name="zXv05"></a>
#### DELETE ： 删除文件

   - 删除服务端的文件

DELETE方法用来删除文件,是与PUT相反的方法。 DELETE方法按请求URI删除指定的资源

   - 和PUT方法一样，鉴于HTP/1.1的PUT方法自身不带验证机制,存在安全性问题,因此一般的web网站不使用该方法。
<a name="51XVr"></a>
#### OPTIONS：询问支持的方法

   - 查询方法

OPTIONS方法用来查询针对请求URI指定的资源支持的方法。
<a name="zoIkC"></a>
#### TRACE： 追踪路径
TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方发送请求时,在Max- Forwards首部字段中填入数值,每经过一个服务器端就将该数字减1,当数值刚好减到0时,就停止继续传输,最后接收到请求的服务器端则返回状态码200OK的响应。

   - 应用场景：
      - 客户端通过 TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为,请求想要连接到源目标服务器可能会通过代理中转, TRACE方法就是用来确认连接过程中发生的一系列操作。
<a name="WdITv"></a>
#### CONNECT：要求用隧道协议连接代理
CONNECT方法要求在与代理服务器通信时建立隧道,实现用隧道协议进行TCP通信。主要使用SSL( Secure Sockets Layer,安全套接层)和TLs( Transport Layer Security,传输层安全)协议把通信内容加密后经网络隧道传输

   - 使用：<br />`CONNECT 代理服务器名:端口号 HTTP版本`
<a name="t1NAG"></a>
### 使用方法下达命令

- 向请求URI指定的资源发送请求报文时，采用称为方法的命令
   - 方法的作用在于,可以指定请求的资源按期望产生某种行为。方法中有GET、POST和HEAD等。
   - GET    获取资源    HTTP 1.0/1.1
   - POST    传输实体主体    HTTP 1.0/1.1
   - PUT    传输文件    HTTP 1.0/1.1
   - HEAD    获得报文首部    HTTP 1.0/1.1
   - DELTTE    删除文件    HTTP 1.0/1.1
   - OPTIONS    询问支持的方法    HTTP 1.0
   - TRACE    追踪路径    HTTP 1.0
   - CONNECT    要求用隧道协议连接代理    HTTP 1.0
   - LINK    建立和资源之间的联系    HTTP 1.0
   - UNLINE    断开连接的关系    HTTP 1.0
<a name="XEfAy"></a>
### 持久连接节省通信量
HTP协议的初始版本中,每进行一次HTTP通信就要断开一次TCP连接。

   - 在浏览多张图片的HTML页面的时候，请求HTML文档建立一次连接断开连接，获取图片又要建立和断开一次连接，“增加了通信量的开销”
<a name="kUc49"></a>
#### 持久连接
为了让客户端和服务器保持连接来传输，HTTP/1.1和一部分的HTP1.0想出了持久连接(HTTPPersistentconnections,也称为HTTPkeep-alive或HTTPconnectionreuse)的方法

   - 特点：只要任意一端没有明确的提出断开连接，则保持TCP来连接状态
   - 建立一次TCP连接就可以一次性发送请求的资源了
   - 在HTTP/1.1中，所有的连接默认都是持久连接
<a name="XGr2V"></a>
#### 管线化
从前发送请求后需要等待并受到回应，才能发送下一个请求。管线化技术，即不用等待也可以发送下一个请求

   - 可以做到同时并行发送多个请求，不需要一个接一个的等待
<a name="ZXyMw"></a>
#### 使用Cookie的状态管理
HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。

   - 如果让服务器管理全部客户端状态则会成为负担
   - Cookie技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态
   - 多用于Web登录
   - Cookie会根据从服务器端发送的响应报文内的一个叫做 Set-cookie的首部字段信息,通知客户端保存 Cookie。
   - 当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入 Cookie值后发送出去
   - 服务器端发现客户端发送过来的 Cookie后,会去检查究竟是从个客户端发来的连接请求,然后对比服务器上的记录,最后得到之前的状态信息
<a name="nsQdJ"></a>
## HTTP报文内的HTTP信息
<a name="PJfqx"></a>
### HTTP报文
用于HTTP协议交互的信息被称为HTTP报文

   - 请求端(客户端)的HTP报文叫做请求报文
   - 响应端(服务器端)的叫做响应报文
   - HTTP报文大致分为
      - 报文首部
      - 报文主体
      - 不一定要有报文主体
<a name="taRpE"></a>
### 请求报文以及响应报文的结构
报文首部：

   - 请求行    /    状态行
   - 请求首部字段    /    响应首部字段
   - 通用首部字段
   - 实体首部字段
   - 其他

**请求行：**

   - 包含用于请求的方法，请求URI和HTTP版本

**状态行：**

   - 包含表名响应结果的状态码，原因短语和HTTP版本

**首部字段：**

   - 包含表示请求和响应的各种条件和属性的各类首部


<br />一般有4种首部,分别是:通用首部、请求首部、响应首部和实体首其他可能包含HTP的RFC里未定义的首部( Cookie等)。
<a name="rfXt8"></a>
### 编码提升传输速率

- HTTP传输数据可以在传输过程中通过编码提升传输速率。通过在传输时编码,能有效地处理大量的访问请求。但是回小号更多CPU等资源
<a name="PJfR2"></a>
#### 报文主体和实体主体的差异

- 报文<br />是HTTP通信中的基本单位,由8位组字节流(octetsequence其中octet为8个比特)组成,通过HTTP通信传输
- 实体<br />作为请求或响应的有效载荷数据(补充项)被传输,其内容由实体首部和实体主体组成。

HTTP报文的主体用于传输请求或响应的实体主体。
<a name="jqrbv"></a>
#### 压缩传输的内容编码
内容编码指明应用在实体内容上的编码格式,并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。

- 常用的内容编码
- gzip(GNU zip)
- compress (UNIX 系统的标准压缩)
- deflate (zlib)
- identity (不进行编码)
<a name="Bf5i2"></a>
#### 分割发送的分块传输编码
在传输大容量数据是，通过把数据分割成多块，能够让浏览器逐步显示页面。

- 这种把实体主体分块的功能称为分块传输编码( Chunked TransferCoding)
- 分块传输编码会将实体主体分成多个部分(块)。每一块都会用十六进制来标记块的大小,而实体主体的最后一块会使用“0（CR+LF）”来标
- 使用分块传输编码的实体主体会由接收的客户端负责解码,恢复到编码前的实体主体。
<a name="jR4ZJ"></a>
### 发送多种数据的多部份对象集合
HTTP协议中也采纳了多部分对象集合,发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。

- multipart/form-data
   - 在Web表单文件上传时使用。
- multipart/byteranges
   - 状态码206( Partial Content,部分内容)响应报文包含了多个范围的内容时使用。
- multipart/form;data
- multipart / byteranges
<a name="NCI7i"></a>
### 获取部分内容的范围请求
如果下载过程中遇到网络中断的情况,那就必须重头开始。为了解决上述问题,需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。<br />要实现该功能需要指定下载的实体范围。像这样,指定范围发送的请求叫做范围请求

   - 对一份10000字节大小的资源,如果使用范围请求,可以只请求5001~10000字节内的资源。

执行范围请求时，会用到首部字段Range来制定资源的byte范围

   - 5001~10000字节
      - Range: bytes=5001-10000
   - 从5001字节之后全部的
      - Range:bytes=5001-
   - 从一开始到3000字节和5000~7000字节的多重范围
      - Range : byte=-3000,5000-7000
   - 针对范围请求,响应会返回状态码为206 Partial Content的响应报文。另外,对于多重范围的范围请求,响应会在首部字段 ContentTpe标明 multipart/byteranges后返回响应报文。
<a name="Y8qvO"></a>
### 内容协商返回最合适的内容
同一个Web网站有可能存在着多份相同内容的页面。比如英语版和中文版的Web页面,它们内容上虽相同,但使用的语言却不同。

   - 应用场景：<br />当浏览器的默认语言为英语或中文,访问相同URI的Web页面时则会显示对应的英语版或中文版的Web页面。这样的机制称为内容协商

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉,然后提供给客户端最为适合的资源。
<a name="g87vD"></a>
## 返回结果的HTTP状态码
<a name="yoNOa"></a>
### 状态码告知从服务器端返回的结果请求
状态码的职责是当客户端向服务器端发送请求时,描述返回的请求结果。借助状态码,用户可以知道服务器端是正常处理了请求,还是出现了错误。

- 响应的状态码可描述请求的处理结果
- 数字中的第一位指定了响应类别,后两位无分类。
- 1XX    信息性状态码    接受的请求正在处理
- 2XX    成功状态码    请求正常处理完毕
- 3XX    重定向状态码    需要进行附加操作以完成请求
- 4XX    客户端错误状态码    服务器无法处理请求
- 5XX    服务器错误状态码    服务器处理请求出错
<a name="6ecH2"></a>
### 2XX 成功
<a name="3lz98"></a>
#### 200 OK

   - 表示客户端发来的请求在服务器端被正常处理了
   - 在响应报文内,随状态码一起返回的信息会因方法的不同而发生改变。
      - 使用GET方法时,对应请求资源的实体会作为响应返回:而使用HEAD方法时,对应请求资源的实体首部不随报文主体作为响应返回(即在响应中只返回首部,不会返回实体的主体部
<a name="2H6cF"></a>
#### 204 No Content 

   - 该状态码代表服务器接收的请求已成功处理,但在返回的响应报文中不含实体的主体部分。
      - 也不允许返回任何实体的主体
   - 案例：当从浏览器发出请求处理后,返回204响应,那么浏览器显示的页面不发生更新。
      - 一般只需要从客户端王服务器发送信息，而对客户端不需要发送新信息内容的情况下使用
<a name="7QaBg"></a>
#### 206 Partial Content
该状态码表示客户端进行了范围请求,而服务器成功执行了这部分的GET请求。响应报文中包含由 Content-range指定范围的实体内容。
<a name="reCT4"></a>
### 3XX 重定向
<a name="JnF5Y"></a>
#### 303 Moved Permanently
永久性重定向。该状态码表示请求的资源已被分配了新的URI,以后应使用资源现在所指的URI。也就是说,如果已经把资源对应的URI保存为书签了,这时应该按 Location首部字段提示的URI重新保存。

   - 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。
<a name="YEGWA"></a>
#### 302 Found
临时性重定向。该状态码表示请求的资源已被分配了新的URI,希望用户(本次)能使用新的URI访问。

   - 由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。
   - 302状态码代表的资源不是被永久移动，知识临时性质的，移动的资源对应的URI将来还有可能发生改变。
- http 协议的 301 和 302 状态码都代表重定向。浏览器请求某url收到这两个状态码时，都会显示和跳转到 Response Headers 中的Location。即在浏览器地址输入 url A，却自动跳转到url B。
<a name="uABKl"></a>
#### 303 See Other
该状态码表示由于请求对应的资源存在着另一个URI,应使用GET方法定向获取请求的资源

- 303状态码和302 Found状态码有着相同的功能,但303状态码明确表示客户端应当采用GET方法获取资源,这点与302状态码有区别
<a name="5nCG5"></a>
#### 304 Not Modified
该状态码表示客户端发送附带条件的请求时,服务器端允许请求访问资源,但未满足条件的情况。304状态码返回时,不包含任何响应的主体部分。304虽然被划分在3XX类别中,但是和重定向没有关
<a name="zHZvp"></a>
#### 307 Temporary Redirect
临时重定向。该状态码于302 Found有着相同的有含义。尽管302禁止POST变换成GET,但实际使用时大家并不遵守。

- 307会遵照浏览器标准,不会从POST变成GET。但是,对于处理响应时的行为,每种浏览器有可能出现不同的情况。
<a name="rz0Nr"></a>
### 4XX 客户端错误
<a name="0eYrQ"></a>
#### 400 Bad Request
         该状态码表示请求报文中存在语法错误。当错误发生时,需修改请求的内容后再次发送请求。另外,浏览器会像200 OK一样对待该状态
<a name="2odQD"></a>
#### 401 Unauthorized
该状态码表示发送的请求需要有通过HTTP认证(BASIC认证DIGEST认证)的认证信息。另外若之前已进行过1次请求,则表示用户认证失败。<br />返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询( challenge)用户信息。当浏览器初次接收到401响应,会弹出认证用的对话窗口。
<a name="P0tGb"></a>
#### 403 Forbidden
该状态码表明对请求资源的访问被服务器拒绝了。

   - 服务器端没有必要给出拒绝的详细理由,但如果想作说明的话,可以在实体的主体部分对原因进行描述，这样就能让用户看到了
<a name="M0guk"></a>
#### 404 Not Found
该状态码表明服务器上无法找到请求的资源。除此之外,也可以在服务器端拒绝请求且不想说明理由时使用
<a name="oLovR"></a>
### 5XX服务器错误
5XX的响应结果表名服务器本身发生错误
<a name="MAQZ5"></a>
#### 500 Internal Server Error
该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。
<a name="wnFex"></a>
#### 503 Service Unavaliable 
该状态码表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求。如果事先得知解除以上状况需要的时间,最好写入Retryafter首部字段再返回给客户端。
<a name="FQSwV"></a>
### 状态码和状况的不一致
不少返回的状态码响应都是错误的,但是用户可能察觉不到这点。比如Web应用程序内部发生错误,状态码依然返回200OK,这种情况也经常遇到。
<a name="x7MV7"></a>
## 与HTTP协作的Web服务器
一台Web服务器可搭建多个独立域名的web网站,也可作为通信路径上的中转服务器提升传输效率。
<a name="wx7XN"></a>
### 用单台虚拟主机实现多个域名
HTP.1规范允许一台HTP服务器搭建多个Web站点

   - 比如,提供Wb托管服务( Web Hosting Service)的供应商,可以用一台服务器为多位客户服务,也可以以每位客户持有的域名运行各自不同的网站。这是因为利用了虚拟主机( Virtual Host,又称虚拟服务器)的功能。
<a name="Dk1Hz"></a>
### 通信数据转发程序：代理、网关、隧道

- 代理
   - 代理是一种有转发功能的应用程序,它扮演了位于服务器和客户端“中间人”的角色,接收由客户端发送的请求并转发给服务器,同时也接收服务器返回的响应并转发给客户端
- 网关
   - 网关是转发其他服务器通信数据的服务器,接收从客户端发送来的请求时,它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉,自己的通信目标是一个网关
- 隧道
   - 隧道是在相隔甚远的客户端和服务器两者之间进行中转,并保持双方通信连接的应用程序。
<a name="JM5fQ"></a>
#### 代理
代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI,会直接发送给前方持有资源的目标服务器

   - 使用代理服务器的理由有<br />利用缓存技术减少网络带宽的流量,组织内部针对特定网站的访问控制,以获取访问日志为主要目的,等等。
   - 代理有多种使用方法,按两种基准分类。一种是是否使用缓存,另种是是否会修改报文。
   - 缓存代理<br />代理转发响应时,缓存代理会预先将资源的副本(缓存)保存在代理服务器上。当代理再次接收到对相同资源的请求时,就可以不从源服务器那里获取资源,而是将之前缓存的资源作为响应返回
   - 透明代理<br />转发请求或响应时，不对报文做任何加工的代理类型被称为i透明代理
<a name="mOK1D"></a>
#### 网关
利用网关可以由HTTP请求转化为其他协议通信<br />网关能使通信线路上的服务器提供非HTTP协议服务

   - 利用网关可以提高通信的安全性
      - 连接数据库，使用sql语句查询数据时...
<a name="YxgpT"></a>
#### 隧道
可按要求建立起一条与其他服务器的通信线路,届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信
