---
title: 可重复锁
description: 可重复锁笔记
date: 2022-07-28
slug: 
image: 
categories:
    - 其他
    - 软件技能
tags:
    - 其他
    - 软件技能
    - 多线程
    - 可重复锁
updated: 2022-07-28
comments: false
---
# 可重入锁原理

## 可重入锁介绍

首先，在Synchronized和ReentrantLock的区别中，两者都是可重入锁，那么究竟什么是可重入锁呢？其内部原理又是如何实现的呢？

概念：可重入锁意味着：若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对**单个线程执行时重新进入同一个子程序**仍然是安全的。

通俗来说：当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是重入锁，请求就会成功，否则阻塞。

在 java 内部，同一线程在调用自己类中其他 synchronized 方法/块或调用父类的 synchronized 方法/块都不会阻碍该线程的执行。就是说同一线程对同一个对象锁是可重入的，而且同一个线程可以获取同一把锁多次，也就是可以**多次重入**。因为java线程是基于“每线程（per-thread）”，而不是基于“每调用（per-invocation）”的（java中**线程获得对象锁的操作是以线程为粒度**的，per-invocation 互斥体获得对象锁的操作是以每调用作为粒度的）

**关于使用synchronized同步锁释放的时机**

```
使用synchronized同步锁释放的时机。我们知道程序执行进入同步代码块中monitorenter代表尝试获取锁，退出代码块monitorexit代表释放锁。而在程序中，是无法显式释放对同步监视器的锁的，而会在如下4种情况下释放锁。

1、当前线程的同步方法、代码块执行结束的时候释放

2、当前线程在同步方法、同步代码块中遇到break 、 return 终于该代码块或者方法的时候释放。

3、出现未处理的error或者exception导致异常结束的时候释放

4、程序执行了 同步对象 wait 方法 ，当前线程暂停，释放锁

 

在以下两种情况不会释放锁。

1、代码块中使用了 Thread.sleep()  Thread.yield() 这些方法暂停线程的执行，不会释放。

2、线程执行同步代码块时，其他线程调用 suspend 方法将该线程挂起，该线程不会释放锁 ，所以我们应该避免使用 suspend 和 resume 来控制线程 。
```

**重入锁实现可重入性原理或机制是：**

```
每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。
```

### 使用ReentrantLock的注意点

ReentrantLock 和 synchronized 不一样，需要手动释放锁，所以使用 ReentrantLock的时候一定要**手动释放锁**，并且**加锁次数和释放次数要一样**

## ReentrantLock(可重入锁)和synchronized区别

1. **可重入性：**
   `ReentrantLock`字面意思即为再进入锁，称为可重入锁，其实`synchronize`所使用的锁也是可以重入的，两者关于这个区别不打，它们都是同一个线程进入一次，锁的计数器进行自增，要等到**锁的计数器**下降为零时，才能释放锁

2. **锁的实现：**
   `synchronized`依赖于JVM实现无法了解底层源码，而`ReentrantLock`基于JDK实现通过阅读源码了解实现，区别就类似于操作系统控制实现与用户使用代码实现。

3. **性能区别：**
   在synchronized优化以前，性能比ReentrantLock差很多，但自从synchronize引入了偏向锁、轻量级锁（自选锁）后 ，也就是自循锁后，两者性能差不多（JDK 1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”）。在两种场景下都可以使用，官方更推荐使用synchronized，因为写法更容易。synchronized的优化其实是借鉴了ReentrantLock中的CAS技术，都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。

4. **功能区别：**

   * 便利性：synchronized更便利，它是由编译器保证加锁与释放。ReentrantLock是需要手动声明与释放锁，所以为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。
   * 锁的细粒度和灵活度：ReentrantLock优于synchronized

5. ReentrantLock独有的功能

   * ReentrantLock可以指定是公平锁还是非公平锁，synchronized只能是非公平锁。（所谓公平锁就是先等待的线程先获得锁）

   * 提供了一个Condition类，可以分组唤醒需要唤醒的线程。不像是synchronized要么随机唤醒一个线程，要么全部唤醒。

   * 提供能够中断等待锁的线程的机制，通过lock.lockInterruptibly()实现，这种机制ReentrantLock是一种自选锁，通过循环调用CAS操作来实现加锁。性能比较好的原因是避免了进入内核态的阻塞状态。想进办法避免线程进入内核阻塞状态， 是我们分析和理解锁设计的关键

     ```
     如果满足ReentrantLock三个独有的功能，那么必须使用ReentrantLock。其他情况下可以根据性能、业务场景等等来选择synchronized还是ReentrantLock
     ```



